# 🔐 JWT 토큰 인증 체크 구현 가이드

## 📌 개요
현재 프로젝트는 JWT 토큰 기반 인증이 구현되어 있습니다.  
게시물 작성, 댓글 작성, 리뷰 작성 등 **로그인이 필요한 기능**을 구현할 때는 반드시 토큰 인증 체크를 해야 합니다.

---

## ⚠️ 절대 하면 안 되는 것

### ❌ BAD: memberNo를 클라이언트에서 직접 받기
```java
@PostMapping("/foods")
public ResponseEntity<?> createPost(@RequestBody CreatePostRequest req) {
    // req.getMemberNo()를 그대로 사용 - 위험!
    postService.createPost(req.getMemberNo(), req.getContent());
    return ResponseEntity.ok().build();
}
```
**문제점**: 클라이언트가 다른 사람의 memberNo를 보내면 그 사람 대신 글을 쓸 수 있음!

---

## ✅ 올바른 방법 3가지

### 방법 1️⃣: @AuthenticationPrincipal 사용 (가장 추천!)

```java
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import com.eat.today.configure.security.CustomUserDetails;

@PostMapping("/foods")
public ResponseEntity<?> createPost(
        @AuthenticationPrincipal CustomUserDetails userDetails,  // 자동으로 로그인 사용자 주입
        @RequestBody CreatePostRequest req) {
    
    // 로그인한 사용자 정보 가져오기
    Integer memberNo = userDetails.getMemberNo();
    String email = userDetails.getUsername();
    
    postService.createPost(memberNo, req.getContent());
    return ResponseEntity.ok().build();
}
```

**장점**: 
- 가장 간단하고 명확
- Spring이 자동으로 현재 로그인한 사용자 정보를 주입
- 토큰이 없거나 유효하지 않으면 자동으로 401 에러

---

### 방법 2️⃣: SecurityContextHolder 직접 사용

```java
import org.springframework.security.core.context.SecurityContextHolder;
import com.eat.today.configure.security.CustomUserDetails;

@PostMapping("/comments")
public ResponseEntity<?> createComment(@RequestBody CommentRequest req) {
    
    // 현재 인증된 사용자 정보 가져오기
    CustomUserDetails userDetails = (CustomUserDetails) SecurityContextHolder
            .getContext()
            .getAuthentication()
            .getPrincipal();
    
    Integer memberNo = userDetails.getMemberNo();
    
    commentService.createComment(memberNo, req.getContent());
    return ResponseEntity.ok().build();
}
```

**사용 시기**: 
- Service 레이어에서 현재 사용자 정보가 필요할 때
- 메서드 중간에 사용자 정보가 필요할 때

---

### 방법 3️⃣: @PreAuthorize로 권한 체크 (ADMIN 전용 기능)

```java
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import com.eat.today.configure.security.CustomUserDetails;

// ADMIN만 가능
@PreAuthorize("hasRole('ADMIN')")
@PostMapping("/alcohols")
public ResponseEntity<?> createAlcohol(
        @AuthenticationPrincipal CustomUserDetails userDetails,
        @RequestBody AlcoholRequest req) {
    
    alcoholService.createAlcohol(req);
    return ResponseEntity.ok().build();
}

// USER 이상이면 가능
@PreAuthorize("hasAnyRole('USER', 'ADMIN')")
@PostMapping("/foods")
public ResponseEntity<?> createFood(...) {
    // ...
}

// 본인 또는 ADMIN만 수정 가능
@PreAuthorize("hasRole('ADMIN') or #memberNo == authentication.principal.memberNo")
@PatchMapping("/members/{memberNo}")
public ResponseEntity<?> updateMember(
        @PathVariable Integer memberNo,
        @RequestBody UpdateRequest req) {
    // ...
}
```

---

## 📝 실제 적용 예시

### Before (위험) ❌
```java
@PostMapping("/foods")
public ResponseEntity<FoodPostResponse> createPost(@RequestBody CreatePostRequest req) {
    // 클라이언트가 보낸 memberNo를 그대로 사용
    FoodPostResponse body = svc.createPost(req.getMemberNo(), req);
    return ResponseEntity.ok(body);
}

@DeleteMapping("/comments/{commentId}")
public void deleteComment(
        @PathVariable Integer commentId,
        @RequestParam Integer memberNo) {  // ❌ 위험!
    commentService.delete(commentId, memberNo);
}
```

### After (안전) ✅
```java
@PostMapping("/foods")
public ResponseEntity<FoodPostResponse> createPost(
        @AuthenticationPrincipal CustomUserDetails userDetails,  // ✅ 안전
        @RequestBody CreatePostRequest req) {
    
    // 토큰에서 가져온 실제 로그인 사용자
    Integer memberNo = userDetails.getMemberNo();
    
    FoodPostResponse body = svc.createPost(memberNo, req);
    return ResponseEntity.ok(body);
}

@DeleteMapping("/comments/{commentId}")
public void deleteComment(
        @PathVariable Integer commentId,
        @AuthenticationPrincipal CustomUserDetails userDetails) {  // ✅ 안전
    
    Integer memberNo = userDetails.getMemberNo();
    commentService.delete(commentId, memberNo);
}
```

---

## 🔧 Service 레이어에서 사용하기

Controller가 아닌 Service에서도 현재 로그인 사용자가 필요할 수 있습니다.

```java
@Service
@Transactional
public class PostCommandServiceImpl implements PostCommandService {
    
    public void createPost(CreatePostRequest req) {
        // Service에서 현재 로그인 사용자 가져오기
        CustomUserDetails userDetails = (CustomUserDetails) SecurityContextHolder
                .getContext()
                .getAuthentication()
                .getPrincipal();
        
        Integer currentMemberNo = userDetails.getMemberNo();
        
        // 게시물 생성 로직
        FoodPost post = new FoodPost();
        post.setMemberNo(currentMemberNo);  // 토큰에서 가져온 진짜 사용자
        post.setContent(req.getContent());
        
        postRepository.save(post);
    }
}
```

---

## 🛡️ 본인 확인이 필요한 경우

수정/삭제 같은 경우 **본인이 작성한 글인지 확인**이 필요합니다.

```java
@DeleteMapping("/foods/{boardNo}")
public ResponseEntity<?> deletePost(
        @PathVariable Integer boardNo,
        @AuthenticationPrincipal CustomUserDetails userDetails) {
    
    Integer currentMemberNo = userDetails.getMemberNo();
    
    // Service에서 본인 확인
    postService.deletePost(boardNo, currentMemberNo);
    
    return ResponseEntity.noContent().build();
}
```

```java
// Service
public void deletePost(Integer boardNo, Integer memberNo) {
    FoodPost post = postRepository.findById(boardNo)
            .orElseThrow(() -> new EntityNotFoundException("게시물을 찾을 수 없습니다."));
    
    // 본인이 쓴 글인지 확인
    if (!post.getMemberNo().equals(memberNo)) {
        throw new IllegalStateException("본인이 작성한 글만 삭제할 수 있습니다.");
    }
    
    postRepository.delete(post);
}
```

---

## 🧪 테스트 방법

### 1. Postman/Thunder Client로 테스트

```
POST http://localhost:8080/command/foods
Headers:
  Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
  Content-Type: application/json
Body:
{
  "content": "맛있는 안주 추천합니다"
}
```

### 2. 토큰 없이 요청하면?
→ 401 Unauthorized 에러 발생 (정상)

### 3. 만료된 토큰으로 요청하면?
→ 401 Unauthorized 에러 발생 (정상)

---

## ❓ 자주 묻는 질문

### Q1: 로그인이 필요 없는 API는?
A: 조회(GET) API는 대부분 로그인 없이 사용 가능합니다.
```java
// 로그인 불필요 - 누구나 게시물 목록 조회 가능
@GetMapping("/foods")
public ResponseEntity<?> getFoodList() {
    return ResponseEntity.ok(postService.getList());
}
```

### Q2: userDetails가 null이면?
A: 토큰이 없거나 유효하지 않으면 Spring Security가 자동으로 401 에러를 반환합니다.  
명시적으로 체크하려면:
```java
if (userDetails == null) {
    return ResponseEntity.status(401).body("로그인이 필요합니다.");
}
```

### Q3: ADMIN인지 확인하려면?
```java
if (userDetails.getMemberRole() == MemberEntity.Role.ADMIN) {
    // ADMIN 전용 로직
}
```

또는
```java
@PreAuthorize("hasRole('ADMIN')")
```

---

## 📞 문의사항
인증/보안 관련 문의: Spring Security 담당자에게 연락

---

## ✅ 체크리스트

구현 시 다음을 확인하세요:

- [ ] `@RequestParam` 또는 `@RequestBody`로 memberNo를 받지 않았는가?
- [ ] `@AuthenticationPrincipal CustomUserDetails`를 사용했는가?
- [ ] 수정/삭제 시 본인 확인 로직이 있는가?
- [ ] ADMIN 전용 기능에 `@PreAuthorize("hasRole('ADMIN')")`를 붙였는가?
- [ ] 토큰 없이 요청했을 때 401 에러가 발생하는가?


